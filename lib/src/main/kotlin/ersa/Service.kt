/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package ersa

import io.ktor.client.engine.cio.*
import io.ktor.client.*
import io.ktor.client.request.HttpRequestBuilder
import io.ktor.client.request.request
import io.ktor.client.statement.HttpResponse
import io.ktor.http.HttpMethod
import io.ktor.http.URLProtocol
import io.ktor.http.path
import io.github.oshai.kotlinlogging.KotlinLogging
import io.ktor.client.request.parameter
import io.ktor.client.request.setBody


class Courrier(private val scheme: Scheme = Scheme.HTTPS, private val _host: String) {
    private val client = HttpClient(CIO)
    private var userAgent: String = "ersa"
    private var contentType: String = "application/json"
    private var accept: String = "application/json"
    private var connection: String = "keep-alive"
    private val logger = KotlinLogging.logger {}

    suspend fun request(endpoint: Endpoint, method: Method, body: Any?="", headers: Map<String, String>?=null) : HttpResponse {

        // set http method
        val requestBuilder = HttpRequestBuilder()
        when (method) {
            Method.GET -> requestBuilder.method = HttpMethod.Get
            Method.POST -> {
                requestBuilder.method = HttpMethod.Post
                requestBuilder.setBody(body)
            }
            Method.PUT -> {
                requestBuilder.method = HttpMethod.Put
                requestBuilder.setBody(body)
            }
            Method.DELETE -> requestBuilder.method = HttpMethod.Delete
        }

        requestBuilder.url {
            protocol = when (scheme) {
                Scheme.HTTP -> URLProtocol.HTTP
                Scheme.HTTPS -> URLProtocol.HTTPS
            }
            host = _host
            path(endpoint.path)
        }

        // set headers
        requestBuilder.headers.append("User-Agent", userAgent)
        requestBuilder.headers.append("Content-Type", contentType)
        requestBuilder.headers.append("Accept", accept)
        requestBuilder.headers.append("Connection", connection)
        if (endpoint.queryItems != null) {
            for(item in endpoint.queryItems) {
                requestBuilder.parameter(item.key, item.value)
            }
        }
        if (headers != null) {
            for ((key, value) in headers) {
                requestBuilder.headers.append(key, value)
            }
        }

        logger.info { "Making a ${requestBuilder.method.value} request to ${endpoint.path}" }

        return client.request(requestBuilder)
    }

    suspend fun upload(endpoint: Endpoint, fileName: String, fileType: FileType, data: Any, headers: Map<String, String>?=null) : HttpResponse {
        // set http method
        val requestBuilder = HttpRequestBuilder()
        requestBuilder.method = HttpMethod.Post
        requestBuilder.url {
            protocol = when (scheme) {
                Scheme.HTTP -> URLProtocol.HTTP
                Scheme.HTTPS -> URLProtocol.HTTPS
            }
            host = _host
            path(endpoint.path)
        }

        // set headers
        requestBuilder.headers.append("User-Agent", userAgent)
        requestBuilder.headers.append("Accept", accept)
        requestBuilder.headers.append("Connection", connection)
        requestBuilder.headers.append("X-Filename", fileName)

        when(fileType) {
            FileType.JPEG, FileType.JPG -> { requestBuilder.headers.append("Content-Type", "image/jpeg") }
            FileType.HEIC -> { requestBuilder.headers.append("Content-Type", "image/heic") }
            FileType.PNG -> { requestBuilder.headers.append("Content-Type", "image/png") }
            FileType.WEBP -> { requestBuilder.headers.append("Content-Type", "image/webp") }
            FileType.MP3 -> { requestBuilder.headers.append("Content-Type", "audio/mpeg") }
            FileType.WEBA -> { requestBuilder.headers.append("Content-Type", "audio/webm") }
            FileType.MP4 -> { requestBuilder.headers.append("Content-Type", "video/mp4") }
            FileType.WEBM -> { requestBuilder.headers.append("Content-Type", "video/webm") }
            else -> { requestBuilder.headers.append("Content-Type", "application/octet-stream") }
        }
        if (headers != null) {
            for ((key, value) in headers) {
                requestBuilder.headers.append(key, value)
            }
        }
        requestBuilder.setBody(data)

        logger.info { "Making a ${requestBuilder.method.value} request to ${endpoint.path}" }

        return client.request(requestBuilder)
    }
}
